// Code generated by codegen. DO NOT EDIT.

package v1alpha1

import (
	"context"
	"sync"
	"time"

	v1alpha1 "github.com/rancher-sandbox/ob-team-opentelemetry-poc/pkg/apis/v1alpha1"
	"github.com/rancher/wrangler/v3/pkg/apply"
	"github.com/rancher/wrangler/v3/pkg/condition"
	"github.com/rancher/wrangler/v3/pkg/generic"
	"github.com/rancher/wrangler/v3/pkg/kv"
	"k8s.io/apimachinery/pkg/api/equality"
	"k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

// OpenTelemetryStackController interface for managing OpenTelemetryStack resources.
type OpenTelemetryStackController interface {
	generic.ControllerInterface[*v1alpha1.OpenTelemetryStack, *v1alpha1.OpenTelemetryStackList]
}

// OpenTelemetryStackClient interface for managing OpenTelemetryStack resources in Kubernetes.
type OpenTelemetryStackClient interface {
	generic.ClientInterface[*v1alpha1.OpenTelemetryStack, *v1alpha1.OpenTelemetryStackList]
}

// OpenTelemetryStackCache interface for retrieving OpenTelemetryStack resources in memory.
type OpenTelemetryStackCache interface {
	generic.CacheInterface[*v1alpha1.OpenTelemetryStack]
}

// OpenTelemetryStackStatusHandler is executed for every added or modified OpenTelemetryStack. Should return the new status to be updated
type OpenTelemetryStackStatusHandler func(obj *v1alpha1.OpenTelemetryStack, status v1alpha1.StackStatus) (v1alpha1.StackStatus, error)

// OpenTelemetryStackGeneratingHandler is the top-level handler that is executed for every OpenTelemetryStack event. It extends OpenTelemetryStackStatusHandler by a returning a slice of child objects to be passed to apply.Apply
type OpenTelemetryStackGeneratingHandler func(obj *v1alpha1.OpenTelemetryStack, status v1alpha1.StackStatus) ([]runtime.Object, v1alpha1.StackStatus, error)

// RegisterOpenTelemetryStackStatusHandler configures a OpenTelemetryStackController to execute a OpenTelemetryStackStatusHandler for every events observed.
// If a non-empty condition is provided, it will be updated in the status conditions for every handler execution
func RegisterOpenTelemetryStackStatusHandler(ctx context.Context, controller OpenTelemetryStackController, condition condition.Cond, name string, handler OpenTelemetryStackStatusHandler) {
	statusHandler := &openTelemetryStackStatusHandler{
		client:    controller,
		condition: condition,
		handler:   handler,
	}
	controller.AddGenericHandler(ctx, name, generic.FromObjectHandlerToHandler(statusHandler.sync))
}

// RegisterOpenTelemetryStackGeneratingHandler configures a OpenTelemetryStackController to execute a OpenTelemetryStackGeneratingHandler for every events observed, passing the returned objects to the provided apply.Apply.
// If a non-empty condition is provided, it will be updated in the status conditions for every handler execution
func RegisterOpenTelemetryStackGeneratingHandler(ctx context.Context, controller OpenTelemetryStackController, apply apply.Apply,
	condition condition.Cond, name string, handler OpenTelemetryStackGeneratingHandler, opts *generic.GeneratingHandlerOptions) {
	statusHandler := &openTelemetryStackGeneratingHandler{
		OpenTelemetryStackGeneratingHandler: handler,
		apply:                               apply,
		name:                                name,
		gvk:                                 controller.GroupVersionKind(),
	}
	if opts != nil {
		statusHandler.opts = *opts
	}
	controller.OnChange(ctx, name, statusHandler.Remove)
	RegisterOpenTelemetryStackStatusHandler(ctx, controller, condition, name, statusHandler.Handle)
}

type openTelemetryStackStatusHandler struct {
	client    OpenTelemetryStackClient
	condition condition.Cond
	handler   OpenTelemetryStackStatusHandler
}

// sync is executed on every resource addition or modification. Executes the configured handlers and sends the updated status to the Kubernetes API
func (a *openTelemetryStackStatusHandler) sync(key string, obj *v1alpha1.OpenTelemetryStack) (*v1alpha1.OpenTelemetryStack, error) {
	if obj == nil {
		return obj, nil
	}

	origStatus := obj.Status.DeepCopy()
	obj = obj.DeepCopy()
	newStatus, err := a.handler(obj, obj.Status)
	if err != nil {
		// Revert to old status on error
		newStatus = *origStatus.DeepCopy()
	}

	if a.condition != "" {
		if errors.IsConflict(err) {
			a.condition.SetError(&newStatus, "", nil)
		} else {
			a.condition.SetError(&newStatus, "", err)
		}
	}
	if !equality.Semantic.DeepEqual(origStatus, &newStatus) {
		if a.condition != "" {
			// Since status has changed, update the lastUpdatedTime
			a.condition.LastUpdated(&newStatus, time.Now().UTC().Format(time.RFC3339))
		}

		var newErr error
		obj.Status = newStatus
		newObj, newErr := a.client.UpdateStatus(obj)
		if err == nil {
			err = newErr
		}
		if newErr == nil {
			obj = newObj
		}
	}
	return obj, err
}

type openTelemetryStackGeneratingHandler struct {
	OpenTelemetryStackGeneratingHandler
	apply apply.Apply
	opts  generic.GeneratingHandlerOptions
	gvk   schema.GroupVersionKind
	name  string
	seen  sync.Map
}

// Remove handles the observed deletion of a resource, cascade deleting every associated resource previously applied
func (a *openTelemetryStackGeneratingHandler) Remove(key string, obj *v1alpha1.OpenTelemetryStack) (*v1alpha1.OpenTelemetryStack, error) {
	if obj != nil {
		return obj, nil
	}

	obj = &v1alpha1.OpenTelemetryStack{}
	obj.Namespace, obj.Name = kv.RSplit(key, "/")
	obj.SetGroupVersionKind(a.gvk)

	if a.opts.UniqueApplyForResourceVersion {
		a.seen.Delete(key)
	}

	return nil, generic.ConfigureApplyForObject(a.apply, obj, &a.opts).
		WithOwner(obj).
		WithSetID(a.name).
		ApplyObjects()
}

// Handle executes the configured OpenTelemetryStackGeneratingHandler and pass the resulting objects to apply.Apply, finally returning the new status of the resource
func (a *openTelemetryStackGeneratingHandler) Handle(obj *v1alpha1.OpenTelemetryStack, status v1alpha1.StackStatus) (v1alpha1.StackStatus, error) {
	if !obj.DeletionTimestamp.IsZero() {
		return status, nil
	}

	objs, newStatus, err := a.OpenTelemetryStackGeneratingHandler(obj, status)
	if err != nil {
		return newStatus, err
	}
	if !a.isNewResourceVersion(obj) {
		return newStatus, nil
	}

	err = generic.ConfigureApplyForObject(a.apply, obj, &a.opts).
		WithOwner(obj).
		WithSetID(a.name).
		ApplyObjects(objs...)
	if err != nil {
		return newStatus, err
	}
	a.storeResourceVersion(obj)
	return newStatus, nil
}

// isNewResourceVersion detects if a specific resource version was already successfully processed.
// Only used if UniqueApplyForResourceVersion is set in generic.GeneratingHandlerOptions
func (a *openTelemetryStackGeneratingHandler) isNewResourceVersion(obj *v1alpha1.OpenTelemetryStack) bool {
	if !a.opts.UniqueApplyForResourceVersion {
		return true
	}

	// Apply once per resource version
	key := obj.Namespace + "/" + obj.Name
	previous, ok := a.seen.Load(key)
	return !ok || previous != obj.ResourceVersion
}

// storeResourceVersion keeps track of the latest resource version of an object for which Apply was executed
// Only used if UniqueApplyForResourceVersion is set in generic.GeneratingHandlerOptions
func (a *openTelemetryStackGeneratingHandler) storeResourceVersion(obj *v1alpha1.OpenTelemetryStack) {
	if !a.opts.UniqueApplyForResourceVersion {
		return
	}

	key := obj.Namespace + "/" + obj.Name
	a.seen.Store(key, obj.ResourceVersion)
}
